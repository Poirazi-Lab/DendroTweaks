"""
This file was automatically generated by the DendroTweaks toolbox (https://dendrotweaks.dendrites.gr/).
It provides a plain (Python) NEURON code representation of a biophysical model of a single neuron
built using DendroTweaks, which can be run independently of DendroTweaks.

Classes:
    Cell: Represents a biophysical NEURON model of a single neuron with methods to:
        - Load morphology from an SWC file.
        - Distribute passive properties.
        - Insert ion channel mechanisms.
        - Distribute parameters across the neuron.
        - Set the number of segments for each section.
        - Add stimuli and recordings.

Functions:
    load_mechanisms: Load NEURON mechanisms from a specified directory.
    init_simulation: Initialize a NEURON simulation with specified parameters.
    run: Run a NEURON simulation for a given duration.
    get_domain: Retrieve the domain of a given segment.
    linear: Compute a linear function based on distance.
    sinusoidal: Compute a sinusoidal function based on distance.
    exponential: Compute an exponential function based on distance.
    sigmoid: Compute a sigmoid function based on distance.
    gaussian: Compute a Gaussian function based on distance.
    step: Compute a step function based on distance.
    inherit: Inherit a parameter value from the parent segment.
"""

import os

import numpy as np
from numpy import polyval

import neuron
from neuron import h
h.load_file('stdrun.hoc')


class Cell():
    """
    A class representing a biophysical NEURON model of a single neuron.
    """

    def __init__(self, path_to_swc_file: str):
        self.name = os.path.basename(path_to_swc_file).replace('.swc', '')
        self.load_morphology(path_to_swc_file)
        self.distribute_passive()
        self.set_geom_nseg()
        self.insert_mechanisms()
        self.distribute_parameters()

    @property
    def all_segments(self):
        return [seg for sec in self.all for seg in sec]
        
    ### Morphology methods ###

    def load_morphology(self, path_to_swc_file: str) -> None:
        if path_to_swc_file.endswith('.swc'):
            self._load_swc(path_to_swc_file)
        elif path_to_swc_file.endswith('.asc'):
            self._load_asc(path_to_swc_file)
        else:
            raise ValueError(f"File type not supported: {path_to_swc_file}")

    def _load_swc(self, path_to_swc_file: str) -> None:
        h.load_file('import3d.hoc')
        swc_importer = h.Import3d_SWC_read()
        swc_importer.input(path_to_swc_file)
        imported_cell = h.Import3d_GUI(swc_importer, False)
        imported_cell.instantiate(self)

    def _load_asc(self, path_to_asc_file: str) -> None:
        h.load_file('import3d.hoc')
        asc_importer = h.Import3d_Neurolucida3()
        asc_importer.input(path_to_asc_file)
        imported_cell = h.Import3d_GUI(asc_importer, False)
        imported_cell.instantiate(self)

    def distance(self, seg, from_seg=None):
        if from_seg is None:
            from_seg = self.soma[0](0.5)
        return h.distance(from_seg, seg)

    def domain_distance(self, seg):
        parent = self._find_parent_with_different_domain(seg.sec)
        if parent:
            return h.distance(parent(1), seg)
        return 0
    
    def _find_parent_with_different_domain(self, sec):
        parentseg = sec.parentseg()
        if not parentseg:
            return None
        parent = parentseg.sec
        while parent:
            if get_domain(parent(0.5)) != get_domain(sec(0.5)):
                return parent
            parentseg = parent.parentseg()
            if not parentseg:
                return None
            parent = parentseg.sec
        return None

    ### Segmentation methods ###

    def set_geom_nseg(self, d_lambda:float=0.1, f:float=100):
        for sec in self.all:
            sec.nseg = int((sec.L/(d_lambda*h.lambda_f(f, sec=sec)) + 0.9)/2)*2 + 1
        
    ### Mechanism methods ###

    def insert_mechanisms(self):
        
        for sec in self.apic:
            
            sec.insert('Leak')
            sec.insert('CaDyn')
            sec.insert('Ih')
            sec.insert('SKv3_1')
            sec.insert('NaTa_t')
            sec.insert('CaHVA')
            sec.insert('Im')
            sec.insert('CaLVAst')
            sec.insert('SK_E2')
        
        for sec in self.axon:
            
            sec.insert('Leak')
        
        for sec in self.soma:
            
            sec.insert('Leak')
            sec.insert('CaDyn')
            sec.insert('Ih')
            sec.insert('SKv3_1')
            sec.insert('K_Tst')
            sec.insert('Nap_Et2')
            sec.insert('NaTa_t')
            sec.insert('K_Pst')
            sec.insert('CaHVA')
            sec.insert('CaLVAst')
            sec.insert('SK_E2')
        
        for sec in self.dend_31:
            
            sec.insert('Ih')
            sec.insert('Leak')
        

    ### Parameter distribution methods ###

    def set_param(self, seg, param: str, mech: str, value: float) -> None:
        if param == 'Ra':
            setattr(seg.sec, param, value)
        if param == 'cm':
            setattr(seg, param, value)
        else:
            if seg.sec.has_membrane(mech):
                setattr(seg, param, value)
            else:
                if param in ['ena', 'ek', 'eca']:
                    if hasattr(seg, param):
                        setattr(seg, param, value)
                
    def distribute_passive(self):

        for seg in self.all_segments:

            domain = get_domain(seg)
            distance = self.distance(seg)
            domain_distance = self.domain_distance(seg)
            diam = seg.diam
            section_diam = seg.sec.diam

            
            if domain in ['apic', 'axon', 'soma', 'dend_31']:
                self.set_param(seg, "cm", "Independent", 1)
                    
                
            if domain in ['dend_31']:
                self.set_param(seg, "cm", "Independent", 2)
                    
                
            if domain in ['apic']:
                self.set_param(seg, "cm", "Independent", 2)
                    
                
            if domain in ['soma']:
                self.set_param(seg, "cm", "Independent", 1)
                    
                
            if domain in ['axon']:
                self.set_param(seg, "cm", "Independent", 1)
                    
                
            
            if domain in ['apic', 'axon', 'soma', 'dend_31']:
                self.set_param(seg, "Ra", "Independent", 100)
                    
                
            

    def distribute_parameters(self):

        for seg in self.all_segments:

            domain = get_domain(seg)
            distance = self.distance(seg)
            domain_distance = self.domain_distance(seg)
            diam = seg.diam
            section_diam = seg.sec.diam

            
            if domain in ['apic', 'axon', 'soma', 'dend_31']:
                self.set_param(seg, "gbar_Leak", "Leak", 0.0)
                    
                
            if domain in ['soma']:
                self.set_param(seg, "gbar_Leak", "Leak", 3.38e-05)
                    
                
            if domain in ['axon']:
                self.set_param(seg, "gbar_Leak", "Leak", 3.25e-05)
                    
                
            if domain in ['dend_31']:
                self.set_param(seg, "gbar_Leak", "Leak", 4.67e-05)
                    
                
            if domain in ['apic']:
                self.set_param(seg, "gbar_Leak", "Leak", 5.89e-05)
                    
                
            
            if domain in ['apic', 'axon', 'soma', 'dend_31']:
                self.set_param(seg, "e_Leak", "Leak", -90)
                    
                
            
            if domain in ['apic', 'soma']:
                self.set_param(seg, "depth_CaDyn", "CaDyn", 0.1)
                    
                
            
            if domain in ['apic', 'soma']:
                self.set_param(seg, "taur_CaDyn", "CaDyn", 80)
                    
                
            if domain in ['soma']:
                self.set_param(seg, "taur_CaDyn", "CaDyn", 460)
                    
                
            if domain in ['apic']:
                self.set_param(seg, "taur_CaDyn", "CaDyn", 122)
                    
                
            
            if domain in ['apic', 'soma']:
                self.set_param(seg, "cainf_CaDyn", "CaDyn", 0.0001)
                    
                
            
            if domain in ['apic', 'soma']:
                self.set_param(seg, "gamma_CaDyn", "CaDyn", 0.05)
                    
                
            if domain in ['soma']:
                self.set_param(seg, "gamma_CaDyn", "CaDyn", 0.000501)
                    
                
            if domain in ['apic']:
                self.set_param(seg, "gamma_CaDyn", "CaDyn", 0.000509)
                    
                
            
            if domain in ['apic', 'soma']:
                self.set_param(seg, "kt_CaDyn", "CaDyn", 0)
                    
                
            
            if domain in ['apic', 'soma']:
                self.set_param(seg, "kd_CaDyn", "CaDyn", 0)
                    
                
            
            if domain in ['soma']:
                self.set_param(seg, "gbar_K_Tst", "K_Tst", 0.0)
                    
                
            if domain in ['soma']:
                self.set_param(seg, "gbar_K_Tst", "K_Tst", 0.0812)
                    
                
            
            if domain in ['apic', 'axon', 'soma', 'dend_31']:
                self.set_param(seg, "ek", "Independent", -85)
                    
                
            
            if domain in ['soma']:
                self.set_param(seg, "gbar_K_Pst", "K_Pst", 0.0)
                    
                
            if domain in ['soma']:
                self.set_param(seg, "gbar_K_Pst", "K_Pst", 0.00223)
                    
                
            
            if domain in ['apic', 'soma']:
                self.set_param(seg, "gbar_SK_E2", "SK_E2", 0.0)
                    
                
            if domain in ['soma']:
                self.set_param(seg, "gbar_SK_E2", "SK_E2", 0.0441)
                    
                
            if domain in ['apic']:
                self.set_param(seg, "gbar_SK_E2", "SK_E2", 0.0012)
                    
                
            
            if domain in ['apic']:
                self.set_param(seg, "gbar_Im", "Im", 0.0)
                    
                
            if domain in ['apic']:
                self.set_param(seg, "gbar_Im", "Im", 6.75e-05)
                    
                
            
            if domain in ['apic', 'soma']:
                self.set_param(seg, "gbar_CaLVAst", "CaLVAst", 0.0)
                    
                
            if domain in ['soma']:
                self.set_param(seg, "gbar_CaLVAst", "CaLVAst", 0.00343)
                    
                
            if domain in ['apic']:
                self.set_param(seg, "gbar_CaLVAst", "CaLVAst", step(distance, **{'max_value': 0.0187, 'min_value': 0.00018700000000000002, 'start': 685, 'end': 885}))
                    
                
            
            if domain in ['apic', 'axon', 'soma', 'dend_31']:
                self.set_param(seg, "eca", "Independent", 132)
                    
                
            
            if domain in ['soma']:
                self.set_param(seg, "gbar_Nap_Et2", "Nap_Et2", 0.0)
                    
                
            if domain in ['soma']:
                self.set_param(seg, "gbar_Nap_Et2", "Nap_Et2", 0.00172)
                    
                
            
            if domain in ['apic', 'axon', 'soma', 'dend_31']:
                self.set_param(seg, "ena", "Independent", 50)
                    
                
            
            if domain in ['apic', 'soma']:
                self.set_param(seg, "gbar_NaTa_t", "NaTa_t", 0.0)
                    
                
            if domain in ['soma']:
                self.set_param(seg, "gbar_NaTa_t", "NaTa_t", 2.04)
                    
                
            if domain in ['apic']:
                self.set_param(seg, "gbar_NaTa_t", "NaTa_t", 0.0213)
                    
                
            
            if domain in ['apic', 'soma']:
                self.set_param(seg, "gbar_SKv3_1", "SKv3_1", 0.0)
                    
                
            if domain in ['soma']:
                self.set_param(seg, "gbar_SKv3_1", "SKv3_1", 0.693)
                    
                
            if domain in ['apic']:
                self.set_param(seg, "gbar_SKv3_1", "SKv3_1", 0.000261)
                    
                
            
            if domain in ['apic', 'soma']:
                self.set_param(seg, "gbar_CaHVA", "CaHVA", 0.0)
                    
                
            if domain in ['soma']:
                self.set_param(seg, "gbar_CaHVA", "CaHVA", 0.000992)
                    
                
            if domain in ['apic']:
                self.set_param(seg, "gbar_CaHVA", "CaHVA", step(distance, **{'max_value': 0.000555, 'min_value': 5.550000000000001e-05, 'start': 685, 'end': 885}))
                    
                
            
            if domain in ['apic', 'soma', 'dend_31']:
                self.set_param(seg, "gbar_Ih", "Ih", 0.0)
                    
                
            if domain in ['soma']:
                self.set_param(seg, "gbar_Ih", "Ih", 0.0002)
                    
                
            if domain in ['dend_31']:
                self.set_param(seg, "gbar_Ih", "Ih", 0.0002)
                    
                
            if domain in ['apic']:
                self.set_param(seg, "gbar_Ih", "Ih", exponential(distance, **{'vertical_shift': -0.000174, 'scale_factor': 0.0004, 'growth_rate': 0.0028, 'horizontal_shift': -0.398}))
                    
                
            

    ### Stimulation methods ###

    def add_stimuli(self):
        self.add_iclamps()
        self.add_synapses()

    def add_recordings(self):
        recordings = []
        
        
        rec = h.Vector()
        rec.record(self.soma[0](0.5)._ref_v)
        recordings.append(rec)
        return recordings

    def add_iclamps(self):
        iclamps = []
        
        iclamp = h.IClamp(self.soma[0](0.5))
        iclamp.delay = 100.0
        iclamp.dur = 800.0
        iclamp.amp = 0.793
        iclamps.append(iclamp)
        
        return iclamps


# =================================================================================================
# SIMULATION FUNCTIONS
# =================================================================================================

def load_mechanisms(path_to_mod: str, recompile:bool=False) -> None:
    """
    Load NEURON mechanisms from a directory.

    Parameters
    ----------
    path_to_mod : str
        The path to the directory containing the mod files.
    recompile : bool
        Whether to recompile the mod files before loading
    """

    if recompile:
        cwd = os.getcwd()
        os.chdir(path_to_mod)
        os.system('nrnivmodl')
        os.chdir(cwd)
        print(f'Compiled mod files in "{path_to_mod}"')

    neuron.load_mechanisms(path_to_mod)
    print(f'Loaded mod files from "{path_to_mod}"')

def init_simulation(temperature:float=37, dt:float=0.025, v_init:float=-65, cvode:bool=False) -> None:
    """
    Initialize a NEURON simulation.

    Parameters
    ----------
    temperature : float
        The temperature in degrees Celsius.
    dt : float
        The time step of the simulation in ms.
    v_init : float
        The initial membrane potential in mV.
    cvode : bool
        Whether to use the CVode variable time step integrator.
    """
    h.CVode().active(cvode)
    h.celsius = temperature
    h.dt = dt
    h.stdinit()
    h.init()
    h.finitialize(v_init)
    if h.cvode.active():
        h.cvode.re_init()
    else:
        h.fcurrent()
    h.frecord_init()

def run(duration:float=300, **kwargs) -> None:
    """
    Run a NEURON simulation.

    Parameters
    ----------
    duration : float
        The duration of the simulation in ms.
    """
    init_simulation(**kwargs)
    h.continuerun(duration)

# =================================================================================================
# HELPER FUNCTIONS
# =================================================================================================

def get_domain(seg) -> str:
    sec = seg.sec
    sec_name = sec.name()
    domain = sec_name.split('.')[-1].split('[')[0]
    return domain

def linear(distance: float, slope:float = 0, intercept: float = 0) -> float:
    return slope * distance + intercept

def sinusoidal(distance: float, amplitude: float = 0, frequency: float = 1, phase: float = 0) -> float:
    return amplitude * np.sin(frequency * distance + phase)

def exponential(distance: float, vertical_shift:float = 0, scale_factor: float =1, growth_rate: float=1, horizontal_shift: float = 0) -> float:
    return vertical_shift + scale_factor * np.exp(growth_rate * (distance - horizontal_shift))

def sigmoid(distance: float, vertical_shift: float=0, scale_factor: float=1, growth_rate: float=1, horizontal_shift: float=0) -> float:
    return vertical_shift + scale_factor / (1 + np.exp(-growth_rate*(distance - horizontal_shift)))

def gaussian(distance: float, amplitude: float, mean: float, std: float) -> float:
    return amplitude * np.exp(-((distance - mean) ** 2) / (2 * std ** 2))

def step(distance: float, max_value: float,  min_value: float, start: float, end: float) -> float:
    if start < distance < end:
        return max_value
    else:
        return min_value

def inherit(seg, param: str) -> float:
    return getattr(seg.sec.parentseg(), param, np.nan)